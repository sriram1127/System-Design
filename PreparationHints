TinyURL
--------
Length - 7 - 3500 billion possibilities
1000 requests per second - 110 years
Unique Id Generation - zookeeper - or Even/Odd id generation
26 + 26 + 10 = 62 chars
ToShortURL(), ToID() methods
Load Balancing 
Redis instances (Cache)
Consistent Hashing
URL -> Hash -> find the node on the cluster
Virtual Node - Hashing Algorithm to chose the node on the cluster
Uniform random
SQL server
Horizonal Sharding
Backup instances
Read & write operations per second 
GUII
Security Concerns

First Non repeating word 100 GB
-------------------------------
chars 'a' - 'z'
average word length - 6 
1 char - 1 byte in ASCII encoding
Trie - host name, list object
DoublyLinkedList - line, index of line
Parallelism 
26 servers
Round robin - 100 lines
English Dict - 5 MB 
single spaced ?
have special chars ?
Differentiate Caps and lower case ?


Rate Limiter
------------

can divide servers based on the Hashing of the clientId
Load Balancing
use array as circular queue
isAllowed(clientId)
System.currentTimeMillis();
clientId as Key

Map<Integer, HitCounter>

class HitCounter {
  longs hits[] = null; // milliseconds
  int cur = 0;
  public HitCounter() {
    initialize();
  }
  
  private void initialize() {
    hits[] = new int[100];
    Arrays.fill(Long.MAX_VALUE);
  }
}

Hit Counter - count requests for the last five minutes
------------------------------------------------------
timestamps may not be in order.
Distributed Application - scale - complex system

int[] count = new int[300]; total count
int[] times = new int[300]; time in seconds

counter.hit(timestamp) 
int idx = timestamp%300;
if times[idx] == timestamp count[idx]++;
if times[idx] > timestamp discard
if times[idx] < timestamp count[idx] = 1;

counter.getHits()
System.currentTimeMillis/1000 - times[idx] < 300

More servers/nodes
Distribute based on the hashing of the user email id
add up at the end
To maintain currency - use concurrent hashmap - lock the object











